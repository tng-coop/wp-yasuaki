<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>日本語聖書リーダー</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
</head>
<body>
  <div class="container py-5">
    <h1 class="mb-4">日本語聖書リーダー</h1>
    <p id="verse" class="lead">読み込んでいます…</p>
    <button id="new-verse" class="btn btn-primary">新しい節</button>
  </div>

  <script type="module" defer>
    import { EdgeTTSClient, ProsodyOptions, OUTPUT_FORMAT }
      from 'https://esm.sh/edge-tts-client@1.0.2';

    const OSIS_URL =
      'https://raw.githubusercontent.com/seven1m/open-bibles/master/jpn-kougo.osis.xml';

    // TTS client + in-flight refs
    const tts = new EdgeTTSClient();
    let streamRef = null, audioRef = null;

    // UI refs
    const verseEl     = document.getElementById('verse');
    const newVerseBtn = document.getElementById('new-verse');

    // Verse storage
    let verses = [];

    // 1) Load & parse OSIS XML via DOMParser
    async function loadVerses() {
      console.log('[loadVerses] fetching XML from', OSIS_URL);
      const res     = await fetch(OSIS_URL);
      const xmlText = await res.text();
      console.log('[loadVerses] fetched XML, length:', xmlText.length);

      const xmlDoc = new DOMParser().parseFromString(xmlText, 'application/xml');
      const verseNodes = Array.from(xmlDoc.getElementsByTagName('verse'));
      console.log('[loadVerses] total <verse> nodes found:', verseNodes.length);

      verseNodes.forEach((node, i) => {
        const id   = node.getAttribute('osisID');
        const txt  = node.textContent.trim();
        if (id && txt) {
          verses.push({ id, text: txt });
        }
      });

      console.log('[loadVerses] total non-empty verses loaded:', verses.length);
      if (verses.length === 0) {
        throw new Error('No verses found after parsing');
      }
    }

    // 2) Abort any ongoing speech
    function abortSpeech() {
      console.log('[abortSpeech]');
      if (streamRef) {
        console.log('  destroying previous stream');
        streamRef.destroy?.();
        streamRef = null;
      }
      if (audioRef) {
        console.log('  pausing previous audio');
        audioRef.pause();
        URL.revokeObjectURL(audioRef.src);
        audioRef = null;
      }
    }

    // 3) Speak text, aborting previous
    async function speakText(text) {
      console.log('[speakText] speaking', text.slice(0, 30), '…');
      abortSpeech();
      await tts.setMetadata(
        'ja-JP-NanamiNeural',
        OUTPUT_FORMAT.AUDIO_24KHZ_48KBITRATE_MONO_MP3
      );
      const opts = new ProsodyOptions();
      opts.pitch  = 'medium';
      opts.rate   = 1.0;
      opts.volume = 90;

      const chunks = [];
      const stream = tts.toStream(text, opts);
      streamRef = stream;
      stream.on('data', c => {
        chunks.push(c);
        console.log('[speakText] got chunk, count=', chunks.length);
      });
      stream.on('end', () => {
        console.log('[speakText] stream ended, playing');
        const blob  = new Blob(chunks, { type: 'audio/mpeg' });
        const url   = URL.createObjectURL(blob);
        const audio = new Audio(url);
        audioRef = audio;
        audio.play();
      });
    }

    // 4) Click handler with safety checks
    newVerseBtn.addEventListener('click', async () => {
      console.log('[click] New Verse');
      if (verses.length === 0) {
        verseEl.textContent = 'データ読み込み中…';
        console.log('[click] loading verses');
        try {
          await loadVerses();
        } catch (err) {
          console.error('[click] loadVerses error:', err);
          verseEl.textContent = '読み込みエラーが発生しました';
          return;
        }
      }

      if (verses.length === 0) {
        console.error('[click] no verses loaded');
        verseEl.textContent = '利用可能な節がありません';
        return;
      }

      const idx = Math.floor(Math.random() * verses.length);
      const v   = verses[idx];
      console.log('[click] selected', idx, v.id);
      verseEl.textContent = `${v.id}　${v.text}`;
      await speakText(v.text);
    });

    // 5) Initial kick
    console.log('[init] simulating first click');
    newVerseBtn.click();
  </script>
</body>
</html>
